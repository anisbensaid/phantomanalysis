# Project Title

Uncertainty propagation analysis for quantitively measuring the accuracy of reconstructed voxels

## Content
1. SMF.py

This file completes the selective median filter function.  Performs a selected median filter on the image detecting the hot and dead pixels occurring due to camera defects.

2. addReadNoiseToPhantom.py

Add real noise to the phantom object. The real noise is generated by analyzing the sample data.

3. runStatOnSamplesNoise.py

Run statistical analysis on the detected noise results

4. runSMFOnSamples.py

Run SMF on the samples folder. Save the results as well as the detected hot pixels.

5. generateSynthetic.py

Generate phantom object

6. reconstruction.py

Run astra reconstruction algorithm on the input with 2 algorithms: CGLS and SIRT

7. compareTwoTiffFiles.py

Compute the euclidean distance between two tif difference images of the same dimension. 



## Running the tests

### Prerequisites: 
Create a virtual environment and install all libraries defined in requirements.txt
```
python -m pip install -r requirements.txt
```
It is recommended to install ASTRA toolbox with Python support - see https://www.astra-toolbox.com/docs/install.html

1. Generate the phantom object data:
```
python generateSynthetic.py 
```
It will generate a folder test_generation_256_parallel_60 containing 60 projections for the phantom object. The number 256 refers to the z-dimension (number of frames) of the 3D object. The term parallel refers to the imaging configuration (parallel-beam vs cone-beam or fan-beam vs cone-beam).

2. runSMFOnSamples.py
```
python runSMFOnSamples.py samples_every_6_degrees 3520 4656
```
This script will run SMF algorithm on the measured sample data. Last two parameters are the dimension of the sample image. The input test data are 2D projections, for example, folder samples_every_6_degrees contains 60 images sampled by 6 degree increments over 360 degree viewpoints of a sample on a turntable. The output is two folders containing respectively the detected noise and the filtered images. The detected noise will be used for simulating the noise for our phantom data.

3. runStatOnSamplesNoise.py
```
python runStatOnSamplesNoise.py 
```
This script will run a statistical analysis over the detected noise from step 2 to identify the four types of pixels and one of them is saved in constant.tif which is used in step 4. Output: normal.tif, nonconstant.tif, constant.tif and ab.tif. 

4. addReadNoiseToPhantom.py
```
python addReadNoiseToPhantom.py
```
This script adds the detected noise from step 3 to the phantom object. 
Output: different folders hold the noisy phantom data. 
Note: 1. because the dimension of the phantom is not the same as the sample, so in the code dimensions for both are specificied. 2.  It also applies the attenuation transform to the data before adding noisy pixels.

5. runSMFOnSamples.py
```
python runSMFOnSamples.py phantom_256_parallel_60_dynamic 1024 1024
```
After collecting the noisy phantom data, this step will run the SMF algorithm on our noisy phantom data. 
In this example, the output are phantom_256_parallel_60_dynamic_filtered_5000 (saving the filtered result) and phantom_256_parallel_60_dynamic_noise_5000 (saving the detected noise)

6. reconstruction.py
```
python reconstruction.py phantom_256_parallel_60_attenuated sirt
```
```
python reconstruction.py phantom_256_parallel_60_static sirt
```
```
python reconstruction.py phantom_256_parallel_60_static_filtered_5000 sirt
```
or 
```
python reconstruction.py phantom_256_parallel_60_attenuated cgls
```
```
python reconstruction.py phantom_256_parallel_60_static cgls
```
```
python reconstruction.py phantom_256_parallel_60_static_filtered_5000 cgls
```

Run astra reconstruction algorithm on the input data. It takes the folder of projections as well as the algorithm to use. Two algorithms are supported: SIRT and CGLS
The result is saved in test_generation_256_parallel_360_sirt and test_generation_256_parallel_360_cgls resepctively for the example.

7. compareTwoTiffFiles.py
```
python compareTwoTiffFiles.py phantom_256_parallel_60_attenuated_sirt phantom_256_parallel_60_static_filtered_1000_sirt phantom_256_parallel_60_static_sirt static_sirt_60.png
```
or
```
python compareTwoTiffFiles.py phantom_256_parallel_60_attenuated_cgls phantom_256_parallel_60_static_filtered_5000_cgls phantom_256_parallel_60_static_cgls static_cgls_60.png
```
Compute the euclidean distance between two tif images of the same dimension. This script will quantitively measure the difference between the noise-free reconstruction with the following two categories: a. noisy one and b. filtered one.  (blue line and red line) To run it, it takes 4 extra parameters, (clean folder=attenuated, filtered folder=filtered_threshold, and noisy folder=dynamic or static, output file name) 



## Author

* **Yin Huang** 

## Date
April, 2021


